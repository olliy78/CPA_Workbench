; SIO-Treiber, Version 12.03.87
; Aenderungen:
; - Statusabfrage jedesmal, auch wenn zuvor frei gemeldet

cdsioi	equ	dumi		;keine Zeicheneingabe unterstuetzt

; Einzelzeichenausgabe Reg. A
cdsioo:	ld	c,(ix+ltpsd)	;Datenport
	out	(c),a
;;;	res	3,(ix+ltpst)	;Sender nicht frei, Status neu abfragen
	ret

;------------------------------------

; Statusabfrage
cdsios:	ld	a,(ix+ltpst)	;Status
	bit	1,a		;senderseitig blockiert?
	jr	nz,lstsr	;ja, frei rueckmelden
;;;	bit	3,a		;war zuletzt frei gemeldet?
;;;	jr	nz,lstsr1	;ja, Status nicht neu abfr.
;;;				;da naechstes Zeichen gepuffert wird
	or	a		;initialisiert?
	call	z,cdsin1	;nein
	call	lstlr0		;holen Lesereg. 0 nach D
	bit	7,(ix+ltpw5)	;Prozedur DTR?
	JR	Z,lstsdc	;nein
	BIT	5,d		;CTS (d.h. empf.ber.)?
	JR	Z,lstsr		;nein, besetzt
lstsbl:	BIT	2,d		;Sendepuffer leer? (nz bei ja)
; Ausgang Senderstatus
lstsr:
;;;	set	3,(ix+ltpst)
lstsr1:	ld	a,0ffh
	ret	nz		;senderseitig frei
;;;	res	3,(ix+ltpst)
	inc	a		;A=00, ret z
	RET			;senderseitig besetzt
;-----------------------
lstsdc:
	bit	0,d		;Zeichen im Empf.puffer des SIO?
	jr	z,lstsd1	;nein
	LD	C,(ix+ltpsd)	;SIO Daten
	IN	A,(C)		;Zeichen lesen
	LD	(ix+ltpdc),A	;zuletzt empf. Zeichen merken
lstsd1:	LD	A,(ix+ltpdc)	;letztes empf. Zeichen
	and	7fh		;evtl. Paritaet ignorieren
	cp	13H		;DC3?
	jr	z,lstsr		;ja, Empfaenger besetzt
	jr	lstsbl		;nein, Sendebereitschaft testen
;-----------------------

; Reset Interr./Lesen Lesereg.0 nach D
; Reg. A unveraendert
lstlr0:
	ld	c,(ix+ltpsc)	;SIO Kommando
 if iobuc1
	ld	d,00110000b	;Reset Fehler-Interrupt
	out	(c),d
 endif
	LD	d,00010000b	;Reset Ext/Status-Interrupt
	OUT	(C),d		;d.h. CTS in Reg. 0 abspeichern
	IN	d,(C)		;Leseregister 0
	RET
;-----------------------

; (Re-)Initialisierung
; IX auf Steuertabelle
; ret: C zeigt auf Kommandoport
cdsin1:
cdsini:
	LD	(ix+ltpst),11h	;ist initial..; Status neu abfragen
	LD	(ix+ltpdc),11H	;DC1 nach Initialisierung simulieren
	push	ix
	pop	hl
	ld	bc,ltpini
	add	hl,bc
	call	portpr
ltpow5:	LD	e,(ix+ltpw5)	;Prozedurtyp/Bitanzahl
ltpot5:	ld	a,5
	ld	c,(ix+ltpsc)
	OUT	(C),A
	OUT	(C),e
	RET

;-------------------------------------
 if iobuc1

; UC1-Routinen (ausser Senden)

; UC1: Empf.-Status
;==================
; o A=0, ret z	: kein Zeichen empfangen
; o A=ff,ret nz	: Zeichen da
uc1st:	ld	ix,lstuc1	;Stellen IX auf Steuertabelle
uc1si:	;interner Aufruf mit gestelltem IX
	bit	4,(ix+ltpst)	;initialisiert?
	jr	nz,uc1si1	;ja
	di
	xor	a
	ld	(uc1bfp),a	;Puffer leeren
	ld	(ix+ltpw1),00010100b	;Empfinterr jedes Zeichen, Intv.mod.
	call	cdsini		;Initialisierung
 if uc1dat ne kbdsci+1		;bei PC1715 V.24 am gleichen SIO wie Tastatur
	ld	hl,uc1i2	;WR2 programmieren
 	ld	b,2
	otir
 endif
	ei
uc1si1:	ld	a,(uc1bfp)	;Zeichen im Empfpuffer?
	or	a
	ret	z		;nein
	ld	a,0ffh
	ret

 if uc1dat ne kbdsci+1
uc1i2:	db	2,ivsio0	;Interruptvektor
 endif

; UC1: empf. Zeichen an Nutzer
;=============================
; o A:	aeltestes empf. Zeichen

uc1i:	ld	ix,lstuc1	;Stellen IX auf Steuertabelle

uc1ii:	;interner Aufruf mit gestelltem IX
	ei			;UC1:-Interrupt zulassen
uc1iw:	call	uc1si		;Zeichen da?
	jr	z,uc1iw		;nein ***keine Zeitueberwachung!***
	ld	hl,uc1bfp
	di
	ld	c,(hl)
	dec	(hl)		;Pufferlaenge -1
	ld	b,0
	inc	hl		;^(aeltestes Pufferzeichen)
	ld	a,(hl)		;Zeichen nach A
	ld	de,uc1buf+1
	ex	de,hl
	ldir			;Puffer aufschieben
	ei
	bit	7,(ix+ltpst)	;war Stopaufforderung?
	ret	z		;nein
	push	af		;retten Zeichen
	ld	a,(uc1bfp)	;Pufferbelegung
	cp	2*uc1bfl/5	;unter dem Limit?
	call	c,uc1ird	;ja, Senden wieder erlauben
	pop	af
	ret

uc1ird:	res	7,(ix+ltpst)
 if (iobuc1 mod 10)	;DTR
	jp	ltpow5		;DTR wieder setzen
 else		;DC1/DC3
	ld	a,11h		;DC1 (Senden wieder erlauben)
	LD	C,(ix+ltpsd)	;SIO Daten
	OUT	(C),A
	ret
 endif

; UC1: Empf.-Interrupt
;=====================
uc1rin:	ld	(intsp),sp
	ld	sp,intstk
	push	af
	push	hl
	push	de
	push	bc
	push	ix
	ld	hl,uc1rir
	push	hl
	ld	ix,lstuc1		;Stellen IX auf Steuertabelle
	ld	hl,uc1bfp	;Pufferzeiger
	ld	a,(hl)
	cp	4*uc1bfl/5	;Puffer fast voll?
	call	nc,uc1ri1	;ja, DC3 senden bzw. DTR wegnehmen
	inc	(hl)		;+1
	ld	e,(hl)
	ld	d,0
	add	hl,de		;naechste freie Stelle
	LD	C,(ix+ltpsd)	;SIO Daten
	IN	A,(C)		;Zeichen lesen
	ld	(hl),a		;Zeichen in Puffer
	ret
uc1rir:	pop	ix
	jp	intrbc		;fertig
; Stopaufforderung senden
; HL bleibt erhalten
uc1ri1:	set	7,(ix+ltpst)	;merken Stopaufforderung
 if (iobuc1 mod 10)	;DTR
	ld	e,(ix+ltpw5)
	res	7,e		;DTR loeschen
	jp	ltpot5
 else		;DC1/DC3
	ld	a,13h		;DC3 an Partner (Senden stopppen)
	LD	C,(ix+ltpsd)	;SIO Daten
	OUT	(C),A
	ret
 endif

 if errvar
; UC1: Interrupt Empf.-Ueberlauf
;===============================
uc1err:	ld	(intsp),sp
	ld	sp,intstk
	push	af
	push	hl
	push	de
	push	bc
	push	ix
	ld	ix,lstuc1	;Stellen IX auf Steuertabelle
	call	lstlr0		;Ruecksetzen Fehlerbedingung
				;keine Fehlermeldung, da bei
				;Empf.ueberlauf alles noch
				;mehr verzoegert wird
	jr	uc1rir
 endif

; UC1: Empfangspuffer
;====================
uc1bfp:	db	0
uc1buf:	ds	uc1bfl,0 

 endif	;uc1


ngdef.?
	ld	a,2
	jr	nz,crttd1	;nein
	dec	a		;Flag: in Stringde