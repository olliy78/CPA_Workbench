
 if wbootv eq 0
	ld	hl,CCP		;CCP fuer Warmstart kopieren
	ld	de,ccpkop
	ld	bc,ccpkpl+bdskpl
	ldir
 endif

 if (wbootv eq 3) or (wbootv eq 4) or (wbootv eq 5)
	ld	hl,BDOS		;BDOS-Kopf fuer Warmstart kopieren
	ld	de,bdskop
	ld	bc,bdskpl
	ldir
 endif


; Ende der Kaltstart-Initialisierungen
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	ei
	ld	hl,kalts1	;erneuten kaltstart
	ld	(BIOS00+1),hl	;umlenken
	LD	HL,kaltm	;Startmeldung, variabler Teil
	CALL	cputms

; Hauptspeicher-Test TPA-Bereich
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	ld	hl,ramtt
	call	cputms
	ld	hl,tpaend+1
	ld	de,kaltsb+kaltsl+3;Kaltstart-Code nicht modif.
	or	a
	sbc	hl,de		;Restlaenge TPA (-3 fuer JP)
	ld	b,h
	ld	c,l
	ex	de,hl
ramtz:	ld	a,(hl)
	cpl
	ld	(hl),a
	cp	(hl)		;angekommen?
	jr	nz,ramter	;nein
	cpl
	ld	(hl),a
	inc	hl
	dec	bc
	ld	a,b
	or	c
	jr	nz,ramtz
	ld	hl,ramtok
	call	cputms
	jp	startc
rameh:	ld	a,h
	call	dcnvoa
	ld	a,l

; Rueckkonvertieren Byte in A nach (DE)
; RET: 2 Zeichen ab (DE), DE zeigt auf naechstes freies Byte
dcnvoa:	call	dcnva

; Rueckkonvertieren A in HEX-Ziffern nach (DE)
; RET: A um 4 bits nach rechts rotiert
;      DE zeigt auf naechstes Byte
dcnvol:
dcnva:	rrca			;linkes Halbbyte
	rrca
	rrca
	rrca
dcnvor:				;rechtes Halbbyte
	push	af		;fuer 2. dcnva-Aufruf retten
	and	0fh
	sub	9+1
	jr	c,dcnvod	;0..9
	add	a,7		;A..F
dcnvod:	add	a,'0'+10
	ld	(de),a
	inc	de
	pop	af
	ret

ramter:	ld	de,ramead
	call	rameh
	ld	de,BDOS+6	;jp BDOS+6 vor diese Stelle
	dec	hl
	ld	(hl),d
	dec	hl
	ld	(hl),e
	dec	hl
	ld	(hl),0c3h
	ld	(bdosre),hl	;diesen Sprung als BDOS setzen
	dec	hl
	ld	de,ramete
	call	rameh
	ld	hl,ramert
	call	cputms

;START CP/M
;~~~~~~~~~~~
startc:
 IF uhrvar		;stellen der Uhr
	ld	hl,uhrini	;Aufforderung fuer Uhr stellen
	call	putmes		;ausgeben
	ld	hl,uhrins
uhrin1:	ld	(hl),'0'
	push	hl
	ld	hl,uhrins
	call	putmes

	call	conin		;Zeichen holen
	pop	hl
	cp	0dh		;CR?
	jp	z,uhrine	;ja, fertig
	cp	08h		;back?
	jr	z,uhrinb	;ja
	cp	7fh		;del?
	jr	z,uhrinb	;ja
	cp	':'		;Trennzeichen?
	jr	nz,uhrinz	;nein
	dec	hl
	ld	a,(hl)
	inc	hl
	cp	':'		;rechts vom ':'?
	jr	z,uhrin1	;ja, Trennzeichen ignorieren
	dec	hl
	ld	(hl),'0'	;sonst fuehrende Null
	inc	hl
	jr	uhrinl
uhrinz:	cp	'0'		;Ziffer
	jr	c,uhrin1	;nein
	cp	'9'+1
	jr	nc,uhrin1
uhrinl:	ld	(hl),a		;Zeichen in Text
uhrin2:	inc	hl
	ld	a,(hl)
	cp	8		;rechtes Textende?
	jp	z,uhrine	;ja
	cp	':'		;Trennzeichen
	jr	z,uhrin2	;ja, uebergehen
	jr	uhrin1
uhrinb:	dec	hl		;back ausfuehren
	ld	a,(hl)
	or	a		;linkes Textende?
	jr	z,uhrin2	;ja, back zuweit
	cp	':'		;Trennzeichen?
	jr	z,uhrinb	;ja, uebergehen
	jr	uhrin1
uhrini:	db	0dh,0ah,83h	;Kursor aus, da nicht ok
	db	'- Bitte aktuelle Uhrzeit in der Form HH:MM eingeben!'
 	db	0dh,0ah
	db	'    '		;Uhrzeit einruecken
	db	0		;Ende des Textes
uhrins:	db	'00:00',8,8,8,8,8,0
uhrinn:	db	0dh,0ah,82h,0	;Kursor wieder an
uhrine:	ld	hl,uhrins
	call	putmes
	ld	hl,uhrinn
	call	putmes
	ld	de,uhrins
	ld	hl,bcduhr
	ld	b,2
uhrin4:	ld	a,(de)
	rld
	inc	de
	ld	a,(de)
	rld
	inc	de
	inc	de		;':' uebergehen
	inc	hl
	djnz	uhrin4
 ENDIF

	ld	hl,CCP+3	;zum Eingang mit Kommandoloeschen
 if cldcmx eq 0
	ld	a,(cjungf)
	or	a		;jungfr. Start?
	jr	nz,njung3	;nein
 endif
	LD	HL,kltkom	;Kaltstartkommando
	LD	DE,CCP+7	;in CCP eintragen
	LD	BC,lkaltc
	LDIR
	ld	hl,CCP		;zum Eingang ohne Komm.loeschen
njung3:
	if	(wbootv eq 0) or (wbootv eq 2) or (wbootv eq 3) or (wbootv eq 4) or (wbootv eq 5)
	jp	wbinit		;Warmstart-Initialisierungen
	else
	warmin
	endif

; Meldungen Kaltstart

cputms:
	ld	a,0		;jungfr. Kaltstart?
cjungf	equ	$-1
	or	a
	ret	nz		;nein
	jp	putmes

; Konstanten fuer Kaltstart
;==========================

kaltm:
	db	'CP/A'
	db	', Version '
	version
	db	', TPA '
	hexout	tpa
	db	' - '
	hexout	tpaend

	db	0dh,0ah
	IF	monitor
	db	'- mit BIOS-Monitor'
	ELSE
	db	'- ohne BIOS-Monitor (Taste und Aufruf ignoriert)'
	ENDIF

	db	0dh,0ah
	db	'- Tastatur: K76'
kbdtyp:	db	'??'

 IF oss
	db	0dh,0ah
	db	'- OSS als RAM-Floppy '
osslwt:	db	'M:'
 ENDIF
 IF	kes
	db	0dh,0ah
	db	'- Testram als RAM-Floppy '
keslwt:	db	'M: mit '
kesmc:	db	'??? kByte'
 ENDIF
 IF	em256
	db	0dh,0ah
	db	'- 16-Bit Erweiterungsmodul als RAM-Floppy '
kemlwt:	db	'M: mit '
kemmc:	db	'256 kByte' 
 ENDIF

	db	0dh,0ah
	db	'- Disketten: '
@din	aset	disknb
	IRP	di,<A,B,C,D>
	IF	@din eq 0
	EXITM
	ENDIF
@din	aset	@din-1
	if	@din ne (disknb-1)
	db	'/'
	endif
	db	((disk&di mod 1000)/100) or '0','"('
	db	((disk&di mod 100)/10) or '0'
	db	(disk&di mod 10) or '0'
	db	','
	if	disk&di ge 10000
	db	'DD'
	else
	db	'SD'
	endif
	db	','
	if	(disk&di mod 10000)/1000
	db	'DS'
	else
	db	'SS'
	endif
	db	')'
	ENDM
	db	0dh,0ah
	db	'             max. phys. Sektorlaenge: '
	if	dbufsz le 7
	db	'128'
	else
	decout	<1 shl dbufsz>
	endif
	db	0dh,0ah
 if chdvar eq 0
	db	'- OHNE LST: (Druckausgaben, Sondertasten ignoriert)!'
	db	0dh,0ah
	db	'       ausser bei I/O-Byte, bit 7,6 auf 01 (CRT:)'
 else
 if1
druckt	MACRO	d
	db	'Geraet an Portadresse '
	hexout	d
	ENDM
 endif
	db	'- einige I/O-Byte-Zuordnungen:'
	db	0dh,0ah,'  Bit 7,6 (LST:-Kanal):'
	if	iobtty
	db	0dh,0ah,'      00 (TTY:): '
	druckt	ttydat
	endif
	db	0dh,0ah,'      01 (CRT:): LST:-Ausgabe auf Bildschirm'
	if	ioblpt
	db	0dh,0ah,'      10 (LPT:): '
	druckt	lptdat
	endif
	db	0dh,0ah,'      11 (UL1:): LST:-Ausgabe hex auf Bildschirm'
	if	iobuc1
	db	0dh,0ah,'  Bit 5,4/3,2/1,0 (UP2:-/UR2:-/UC1:-Kanaele):'
	db	0dh,0ah,'      11 (UC1:): '
	druckt	uc1dat
	endif
 endif

	db	0	;ende-flag putmes

; RAM-Test-Texte
;~~~~~~~~~~~~~~~
ramtt:	db	0dh,0ah
	db	'- RAM-Test fuer TPA-Bereich... ',0
ramtok:	db	'TPA ist OK!',0
ramert:	db	0dh,0ah,'!!RAM-Fehler auf Adresse '
ramead:	db	'XXXXH!!  TPA nur bis '
ramete:	db	'YYYYH.',07h,0dh,0ah,0

; Kaltstart-Kommando
;-------------------
kltkom:	db	kaltce-kaltc
kaltc:	coldcm
kaltce:	DB	0		;00h notwendig fuer CCP
lkaltc	equ	$-kltkom	;Laenge gesamtes Kommando

	.DEPHASE
kaltsl	equ	$-kaltsc

kalten	equ	$


	if	oss
alvm	equ	@dsad		;Allocation Vector RAM-Floppy
@dsad	aset	@dsad+(48+7)/8	;reicht fuer 48K (1K Bloecke)
csvm	equ