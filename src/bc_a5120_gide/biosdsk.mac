
;****************************************************
;	Diskettentreiber; Umkleidung des phys. Transfers
;	Version 04.11.88
; Aenderungen:
; - Jeder Fehler in Spur 0, Sektor 1 fuehrt zur Annahme von Systemspuren
;   (A7100-System mit 5" FM und 8272-Hardware mit 128er Sektorlaenge)
; - !!Schnittstelle fuer diskio-Aufruf neu!! (Flags neu, side zusaetzlich)
; - Verify nach Schreiben kann laufwerksspezifisch gewaehlt werden
; - Laufwerkskapazitaet nach phys. LW-Nr in Statuszeile
; - Fehlerkorrektur bei KAYPRO IV fuer C128
; 12.06.88
; - bei stzaus in synflg keine Pflege der Statuszeile
; 06.07.88:
; - Spurnummer generell auf 16 bit erweitert
; 14.10.88
; - Generierung ohne Floppy-Laufwerke moeglich
; 26.10.88
; - Test der Laufwerksbereitschaft bei Select
; 04.11.88
; - bei 5" und 512 Sektorlaenge Dir-Groesse 0
; 12.03.89
; - 'ibmfrm' gestrichen, phys. Formaterkennung fuer SIOS erfolgt immer
;****************************************************

 if1
dskwarm	MACRO
 	IF	dbufsz gt 7
	ld	a,0ffh
	ld	(dbdev),a	;;Puffer ist nicht aktiv
	ENDIF
	ENDM
 endif

; Laufwerksauswahl
;=================
; i C: Laufw. (0=A:, 1=B: ...)
; i E: Bit 0 ist LOGIN-Bit von BDOS (=0, wenn LOGIN)

seldsk:	call	dgetpb		;HL auf DPH stellen, IX auf DPB
	ret	z		;Geraet ex. nicht
	ld	a,c
	ld	(ddrive),a	;Laufwerk merken
	bit	0,e		;LOGIN von BDOS?
	ret	nz		;nein
 if ramfl
;###RAM-Floppy
	bit	dpbfnd,(ix+dpbflg)	;Diskette?
	ret	nz		;nein, fertig
;####
 endif
	push	hl		;^DPH merken

	IF	dbufsz gt 7
	ld	hl,dbdev
	cp	(hl)		;LOGIN fuer gepuffertes Device?
	jr	nz,dselnb	;nein
	ld	(hl),0ffh	;Puffer ist ungueltig
	ld	hl,dbflg
	res	dfbwr,(hl)	;kein veraend. Puffer auszug.!
dselnb:
	ENDIF

 IF format
	bit	dpbfrm,(ix+dpbflg);Formaterkennung unterdr.?
	jr	z,drdfrm	;nein
 ENDIF

; Test der Laufwerks-Bereitschaft; nur dann Select Disk ok
;---------------------------------------------------------
	ld	(drddev),a	;log. LW
	ld	l,(ix+dpbofs)
	ld	h,(ix+dpbofs+1)
	ld	(drdtrk),hl	;auf Beginn des Verzeichnisses
	ld	hl,drdcdb	;Positionieren ohne Fehlerbehandlung
	call	dsktra
	jp	z,selext	;ok
	pop	hl		;^DPH wegschmeissen
	ld	hl,0		;Select Fehler
	ret
drdfrm:

	IF	format
;++++++++++Automatische Format-Erkennung++++++++++
; Reg. C zeigt auf Laufwerk

	IF	dbufsz gt 7
 	call	dbtrw		;Puffer freimachen
				;und auf Lesen schalten
	ld	hl,dbnb
	ld	(hl),0ffh	;Puffernummer ist ungueltig, obwohl evtl.
				;alle anderen Pufferparameter stimmen
				;(da nur 128 Bytes vom Puffer belegt sind)
	ENDIF

	ld	a,c
	ld	(dfrmdv),a
	ld	(dbdev),a

	xor	a
	ld	(ix+dpbflg),a	;ruecksetzen alle Flags
	ld	(ix+dpbsn0),a	;keine Weiter-Numm. auf Ruecks.
	ld	(ix+dpbofs),a	;keine Systemspuren

	ld	(dfrmtr),a	;Spur 0
	ld	(dbtrk),a
	ld	(dbtrk+1),a
	inc	a
	ld	(dbsec),a	;Sektor 1
	ld	(dbsnb),a	;1 phys. Sektor lesen

; Stellen  Sektor-Translate-Tabelle 1,2,3,...
	push	ix
	ld	b,26		;max. Laenge der Tabelle
 IF dsk8mf
	bit	dpbt52,(ix+dpbtyp)	;Tabelle max 52 lang?
	jr	z,nd8mf		;nein
	ld	b,52
nd8mf:
 ENDIF
selstz:	ld	(ix+dpbstr),a
	inc	ix
	inc	a
	djnz	selstz
	pop	ix

; Positionieren auf Spur 0 und analysieren Systemspuren
	call	dsidtr		;beliebigen Sekt.Id lesen
	jr	nz,selsys	;Fehler beim Lesen; Systemsp. annehmen
;				 (z.B. SCP1700 mit 5"FM in Spur 0!!)
	ld	a,h
	ld	(dbslc),a	;setzen Spurformat fuer Sp. 0
	IF	dbufsz le 7
	or	a		;Sektorlaenge 128?
	jr	nz,selsys	;nein, Puffer zu klein - Systemspuren annehmen
	ENDIF
	ld	hl,dbflg
 IF dsk8mf
	res	dioffm,(hl)
	ld	a,(dfrflg)	;Flag zum Lesen des Sektid.
	bit	dioffm,a	;war dazu temporaer FM notwendig?
	jr	z,nfrtfm	;nein
	set	dioffm,(hl)	;sonst fuer Datenlesen uebernehmen
nfrtfm:
 ENDIF
	ld	b,(hl)		;merken Fehlerprotokoll-Bit
	set	dfbtr,(hl)	;kein Fehlerprotokoll
	push	hl
	call	dbtran		;Lesen Spur 0, Sektor 1
	pop	hl
	ld	(hl),b		;setzen Standard fuer Fehlerprotokoll-Bit
	jr	nz,selsys	;Fehler, Systemspuren annehmen
	push	iy
	ld	iy,(dbdma)
	ld	a,(iy+0)	;Format-Loeschbyte
	cp	0e5h		;leere Diskette/geloeschter Eintrag?
	jr	nz,selsy2	;nein, weder/noch
	cp	(iy+1)		;auch danach 0e5h?
	jr	nz,selsy0	;nein, geloeschter Dir-Eintrag
	dec	(ix+dpbofs)	;Flag: leere Disk oder leere Systemsp.
	jr	selsy0		;dpbofs auf 254
selsy2:
	cp	40h		;IBM-Format (SIOS-Daten-Diskette)?
	jr	z,selsy1	;ja, 0 Systemspuren annehmen
	cp	20h		;<=31 ? ("S"YL ist groesser!)
	jr	nc,selsy1	;nein, kann kein Directory sein; 0 Systemsp.
;Systemlader fuer PC1715 beginnt mit 02 oder 03
	ld	a,(iy+20h)	;bei SCP1715-Systemdiskette dort 00h
				;bei MicroDos dort 10h
	or	(iy+21h)	;bei SCP1715-Systemdiskette dort 00h
				;bei CP/A dort Dir-Eintrag (E5 oder Filename)
	jr	z,selsy1	;beides 00h, kein Directory; 0 Systemsp.
selsy0:	dec	(ix+dpbofs)	;=255, wenn Directory; =254 wenn vorn leer
selsy1:
	pop	iy
selsys:

; Analysieren Datenspur

; SS/DS-Analyse
	ld	(ix+dpbstp),2	;Doppel-Step-Impulse
	ld	a,dlgint	;auf LOGIN-Spur
	call	dsidtt		;belieb. SektId Vorderseite lesen
	jr	nz,seldle	;Fehler, unsicheres Format
	ld	d,h		;d:=Sektorlcode, e:=Spur
 IF dsk8mf
	ld	hl,dfrcdb
	bit	dioffm,(hl)	;musste FM erzwungen werden?
	jr	z,selnfm	;nein
	set	dpbffm,(ix+dpbflg)	;sonst ist alles FM
selnfm:	ld	hl,dbflg
	res	dioffm,(hl)	;loeschen fuer normalen Transfer

 ENDIF
 IF dskds
	bit	dpbtds,(ix+dpbtyp)	;ist es ein DS-Laufwerk?
	jr	z,selss		;nein, SS
	push	de		;merken Sektorlaengencode und Spur
	set	dpbfds,(ix+dpbflg)
	ld	a,1+(dlgint*2)	;Rueckseite der Spur,
				;ab der Format bei SS konstant
	call	dsidtt		;beliebigen Sekt.Id Ruecks. lesen
	ld	a,d		;merken side Ruecks.
	ld	l,e		;h:=Sektorlcode, l:=Spur Rueckseite
	pop	de		;wiederherstellen Vorderseite
	jr	nz,selss	;Fehler beim Lesen, SS
	or	a
	sbc	hl,de		;Vorder- gleich Rueckseite?
	jr	z,sel48		;ja; 40 Tr/ 80 Tr unterscheiden
selss:	res	dpbfds,(ix+dpbflg)
 ENDIF

; 40/80 Track Analyse
sel48:	ld	a,e		;trk
	sub	dlgint		;waren 2 Steps richtig? 
	jr	z,seldl1	;ja
	dec	(ix+dpbstp)	;Einzelstep-Impulse
	sub	dlgint		;waere 1 Step richtig?
	jr	z,seldl1	;ja
				;nein, unsicher
seldle:	ld	(ix+dpbslc),0ffh;provozieren 'BAD SECTOR'
	ld	hl,0		;erzeugen 'SELECT' Error
	ex	(sp),hl
	jp	selext

; DS/SS und 40/80 ist unterschieden, es fehlt Sektorlaenge
seldl1:	ld	a,d
	ld	(ix+dpbslc),a	;definieren Sektorlaengencode
 IF	dbufsz le 7
	or	a		;Sektorlaenge 128?
	jr	nz,seldle	;nein, Puffer reicht nicht
 ELSE
	IF	dbufsz lt 10	;Test, ob Disk-Puffer ausreicht
	cp	dbufsz-6	;dpbslc < dbufsz-6?
	jr	nc,seldle	;nein, zu klein
	ENDIF
	or	a		;Sektorlaenge 128?
	jr	nz,seldxl	;nein, normale Sektorfolge
 ENDIF	;dbufsz gt 7
 IF dsk8mf
	bit	dpbt52,(ix+dpbtyp)	;8" MFM?
	jr	z,seldsv	;nein
	bit	dpbffm,(ix+dpbflg)	;als MFM betreiben?
	jr	z,seldxl	;ja, kein Sektorversatz
 ENDIF
seldsv:
; Stellen Sektor-Translate-Tabelle 1,7,13,..
	push	ix
	pop	hl
	ld	bc,dpbstr
	add	hl,bc
	ex	de,hl
	ld	hl,xlt
	ld	c,26
	ldir
seldxl:

	call	dtrsla		;stellen hl entspr. Sektorlaenge
	jr	nz,seldle	;unzulaessig
	ld	bc,dsll		;Laenge eines Eintrags
 IF disk8
	bit	dpbt5z,(ix+dpbtyp)	;8"-LW?
	jr	nz,sel5zl	;nein
	add	hl,bc		;5" uebergehen
	add	hl,bc
	add	hl,bc
	add	hl,bc
  IF dsk8mf
	bit	dpbtdd,(ix+dpbtyp)	;MFM-Laufwerk?
	jr	z,selset	;nein
	bit	dpbffm,(ix+dpbflg) ;als FM zu betreiben?
	jr	nz,selset	;ja
	add	hl,bc		;sonst auf 8" MFM Muster
  ENDIF
	jr	selset		;Format-Werte setzen
sel5zl:
 ENDIF
	bit	1,(ix+dpbstp)	;40 Tr. auf 80er LW?
	jr	nz,seld40	;ja
	ld	a,(ix+dpbptr)	;40er LW?
	cp	40+1
	jr	c,seld40	;ja, 40 Tr. auf 40er LW
	add	hl,bc		;auf 80er Format stellen
seld40:	bit	dpbfds,(ix+dpbflg)	;DS?
	jr	z,seldss	;nein
	add	hl,bc		;auf DS Format
	add	hl,bc
seldss:
selset:
; DPB modifizieren entsprechend erkanntem Format
	ld	c,(hl)		;Zahl der benutzten Spuren
	ld	(ix+dpbtrk),c
	inc	hl
	ld	c,(hl)		;Anzahl 128er Sektoren pro Spur
	ld	(ix+dpbspt),c
	inc	hl
	ld	c,(hl)		;Anzahl der Dir-Eintraege -1
	inc	hl
	ld	a,(hl)		;Anzahl der Systemspuren
	srl	a		;feste Anzahl erzwungen?
	jr	c,seldof	;ja
	bit	7,(ix+dpbofs)	;kann Spur 0 Directory sein?
	jr	z,seldof	;nein, Standardanzahl setzen
	inc	(ix+dpbofs)	;evtl. leere Systemspur?
	jr	z,seldo0	;nein, 0 Systemspuren
	ld	b,a		;retten Anzahl Systemspuren
	ld	(dbtrk),a	;einlesen evtl. moeglicher Datenbeginn
	push	hl
	call	dbtran		; dauert bei falscher Spur etwas laenger
	pop	hl
	ld	a,b
	jr	nz,seldof	;Fehler, mit Systemspuren annehmen
	push	iy
	ld	iy,(dbdma)
	ld	a,(iy+14)	;falls dort Dir, so Byte 14 von Dir =0
	cp	0e5h		;Daten auch leer?
	pop	iy
	ld	a,b
	jr	nz,seldof	;nein, vorn liegen nichtbelegte Systemspuren
seldo0:	xor	a		;sonst ohne Systemspuren
seldof:	ld	(ix+dpbofs),a
	or	a		;0 Systemspuren?
	jr	z,selddr	;ja
	ld	a,c		;Anzahl Dir-Eintraege -1
	cp	192-1		;>=192 Dir-Eintraege ?
	jr	c,selddr	;nein
	ld	c,128-1		;780k hat 128 Dir-Eintraege
selddr:	ld	(ix+dpbdir),c
	inc	hl
	ld	c,(hl)		;Abstand der Blockgroessentab.
	ld	b,0
	add	hl,bc		;auf Blockgroessentabelle
	ld	c,(hl)
	ld	(ix+dpbbls),c
	inc	hl
	ld	c,(hl)
	ld	(ix+dpbblm),c
	inc	hl
	ld	c,(hl)
	ld	(ix+dpbexm),c

; Bestimmen Zahl der abweichenden 128er-Sektoren ab Spur 0

	xor	a
	ld	(dfrmtr),a	;ab Spur 0
		;(gleichz. Spurkorr. bei falschen Doppelstepimpulsen)
sf128z:	call	dsidtr		;beliebigen SektId lesen
	jr	nz,sf128e	;Fehler
	ld	a,h		;Sektorlaenge
	cp	(ix+dpbslc)	;gleich Disketten-Rest?
	jr	z,sf128e	;ja
	ld	a,(ix+dpbflg)
	and	dpbfsm		;bisherige Anzahl abweichender Spuren
	cp	dpbfsm		;Zaehler voll?
	jr	z,sf128e	;ja
	inc	(ix+dpbflg)	;erhoehen abweich. Spurzahl
	ld	hl,dfrmtr	;naechste (logische!) Spur
	inc	(hl)
	jr	sf128z
sf128e:

; Setzen Anzahl der logischen 128er Rekords im Puffer -1
; Es wird immer das Maximum gesetzt, dies setzt eine dichte
; Sektorfolge beim Transfer voraus! (so in dpbstr)

	IF	dbufsz gt 7
	ld	(ix+dpbbfm),+(1 shl (dbufsz-7))-1
	ENDIF

; Berechnen Speicherkapazitaet-1 in BDOS-Bloecken aus
; ((Tracks-dpbofs)*dpbspt/(2**dpbbls))-1
	ld	l,(ix+dpbtrk)
	xor	a
	ld	h,a		;hl:=log. Spurzahl
	ld	e,(ix+dpbofs)
	ld	d,a		;de:=log. offset-Spurzahl
	sbc	hl,de
	ex	de,hl		;de:=log. Daten-Spurzahl
	ld	l,a		;hl:=0
	ld	b,(ix+dpbspt)
dsizmz:	add	hl,de
	djnz	dsizmz		;hl:=(tracks-dpbofs)*dpbspt
dsizme:	ld	b,(ix+dpbbls)
dsizdz:	srl	h
	rr	l
	djnz	dsizdz
	dec	hl
	ld	(ix+dpbsiz),l
	ld	(ix+dpbsiz+1),h
	ld	a,(ix+dpbdir)	;Dir-Groesse
	inc	a
	and	0fch		;abrunden auf durch 4 teilbare Dir-Groesse
	rrca
	rrca			;div 4, da 4 Dir-Eintr. /Sekt.
	ld	(ix+dpbchk),a	;ist Sektorzahl = Check size
	ld	b,(ix+dpbbls)	;block shift
seldla:	rrca			;BDOS-Bloecke fuer Dir.
	djnz	seldla
	ld	b,a
	xor	a
seldal:	scf			;Allocation-Bits fuer Dir.
	rra
	djnz	seldal
	ld	(ix+dpbalc),a
;+++++++++++Ende automatische Formaterkennung+++++++++++++
	ENDIF	;format

selext:
 IF cpastz
; Anzeigen Diskformat als Speicherkapazitaet in kBytes
	ld	a,(synflg)
	bit	stzaus,a	;Anzeige in Statuszeile erlaubt?
	jr	nz,selexx	;nein
; Ermitteln Stelle in Statuszeile
	ld	a,(ix+dpbdnr)
  IF dev eq cpd
	call	flkstz		;Stelle fuer Laufwerkskapazitaet in Statuszeile
  ELSE
	ld	c,a
	ld	hl,statz2+statzk-stzkl
crtm40	equ	$-2
	ld	de,stzkl
	inc	a
selexb:	add	hl,de
	dec	a
	jr	nz,selexb
	ld	(selex5),hl
  ENDIF

	ld	a,c
	add	a,'0'
	call	selex4
	ld	a,':'
	bit	dpbtwv,(ix+dpbtyp)	;Verify nach Schreiben?
	jr	z,selexv	;nein
	ld	a,'v'		;sonst durch 'v' kennzeichnen
selexv:	call	selex4

; (dpbsiz+1)*(2**(dpbbls-3))
	ld	l,(ix+dpbsiz)
	ld	h,(ix+dpbsiz+1)
	inc	hl
	ld	a,(ix+dpbbls)
	sub	3
	jr	z,selex1
selex2:	add	hl,hl
	dec	a
	jr	nz,selex2
selex1:	ld	de,-100		;immer dreistellig
	call	selex3
	ld	de,-10
	call	selex3
	ld	a,l
	or	'0'
	call	selex4
 ENDIF

selexx:	pop	hl		;hl auf DPH
	ret			;Return Seldsk

 IF cpastz
  IF dev eq cpd
  ELSE
selex3:	call	mhldig		;10er Ziffer nach A
selex4:	ld	de,0
selex5	equ	$-2		;Zeiger in Statuszeile
	setbs
	ld	(de),a		;ablegen in Statuszeile
	setram
	inc	de
	ld	(selex5),de
	ret
  ENDIF
 ENDIF


; auf Spur 0 zurueck (vor jedem Dir-Zugriff)
;===================
home:
	IF	dbufsz gt 7
	ld	hl,dbflg
	bit	dfbwr,(hl)	;veraenderter Puffer?
	jr	nz,home1	;ja, nicht freigeben
	ld	a,0ffh		;sonst Diskwechsel erlauben
	ld	(dbdev),a	;Puffer ist nicht aktiv
	ENDIF
home1:	ld	bc,0
;-----------------------

; Einstellen Spur in Reg. BC
;================
settrk:
	ld	(dtrack),bc	;Spur merken
	ret
;-----------------------

; Einstellen Sektor in Reg. C
;==================
setsec:	LD	A,C
	LD	(dsectr),A
	RET
;-----------------------

; Einstellen DMA in Reg. BC
;===============
setdma:	LD	(ddma),BC
	RET
;-----------------------

; Uebersetzung Sektornummer 
;==========================
; Translate-Tab-Adr. in DE, Eingangs-Sektornummer in BC,
;			    Ausgangs-Sektornummer in HL
; Es wird keine Translate-Tabelle benutzt, da die Sektor-
; nummernverwaltung verallgemeinert im nicht-Standard-DPB 
; enthalten ist (auch fuer physische Sektorlaenge <>128)

sectran:
	LD	H,B
	LD	L,C
	inc	hl		;Sektoren zaehlen in CP/A ab 1
	RET
;-----------------------

; Schreiben Sektor
;=================
; Register C (vom BDOS gestellt):
;	=0, wenn normales write
;	=1, wenn directory-write (sofort ausgeben)
;	=2, wenn Beginn eines neuen Datenblocks (kein preread)

write:
 IF @write
	ld	e,c		;retten Reg. C
	ld	a,(ddrive)
	ld	c,a
	call	dgetpb		;ix:=dpb(ddrive)
	jr	z,drwerr	;Geraet ex. nicht
 if ramfl
;###RAM-Floppy
	bit	dpbfnd,(ix+dpbflg)	;Diskette?
	jp	nz,wrramf	;nein
;###
 endif
	ld	hl,dflg
	set	dfwr,(hl)	;Write-Flag setzen

	IF	dbufsz gt 7	;gepufferte Disk E/A
	ld	hl,dbflg
	set	dfbprr,(hl)	;Annahme preread notwendig
	ld	a,e		;A:= Write-Typ
	ld	(dwrtyp),a	;merken Write-Typ
	cp	2		;write to unallocated?
	jr	nz,chkuna	;nein
	ld	a,(ix+dpbblm)	;Zahl der 128-Sekt. im Block -1
	inc	a
	ld	(unacnt),a	;fuer diese Sekt. kein preread
	ld	hl,unadev
	ld	(hl),c
	ld	hl,(dtrack)
	ld	(unatrk),hl
	ld	a,(dsectr)
	ld	(unasec),a
chkuna:	ld	hl,unacnt
	ld	a,(hl)
	or	a		;noch nicht geschr. Sekt. da?
	jr	z,alloc		;nein
	dec	a		;sonst Restzahl -1
	ld	(hl),a
	inc	hl
	ld	a,c
	cp	(hl)		;gleiches Geraet?
	jr	nz,alloc	;nein
	inc	hl
	ld	a,(dtrack)
	cp	(hl)		;gleiche Spur?
	jr	nz,alloc	;nein
	inc	hl
	ld	a,(dtrack+1)
	cp	(hl)
	jr	nz,alloc
	inc	hl
	ld	a,(dsectr)
	cp	(hl)		;gleicher Sektor?
	jr	nz,alloc	;nein
; Vorbereiten naechsten unalloc write-Aufruf
	cp	(ix+dpbspt)	;neue Spur?
	jr	c,unatr1	;nein
	dec	hl
	ld	d,(hl)
	dec	hl
	ld	e,(hl)
	inc	de		;unatrk +1
	ld	(hl),e
	inc	hl
	ld	(hl),d
	inc	hl
	xor	a		;Sektor auf Spuranfang
unatr1:	inc	a		;naechster Sektor
	ld	(hl),a
	ld	hl,dbflg
	res	dfbprr,(hl)	;anzeigen kein preread notw.
	ENDIF
	jr	drw

 ENDIF ;@write

; Abbruch read/write mit E/A-Fehler
drwerr:	ld	a,1
	ret

; Lesen Sektor
;=============

read:
	ld	a,(ddrive)
	ld	c,a
	call	dgetpb		;ix:=dpb(ddrive)
	jr	z,drwerr	;Geraet ex. nicht
 if ramfl
;###RAM-Floppy
	bit	dpbfnd,(ix+dpbflg)	;Diskette?
	jp	nz,rdramf	;nein
;###
 endif
	ld	hl,dflg
	res	dfwr,(hl)	;Lesen anzeigen

 IF dbufsz gt 7
	ld	hl,dbflg
	set	dfbprr,(hl)	;preread notwendig
	ld	a,2
	ld	(dwrtyp),a

alloc:
  IF @write
	xor	a
	ld	(unacnt),a	;Ende unalloc
  ENDIF

 ENDIF

; gemeinsamer Zweig read/write Floppy
;------------------------------------

drw:	ld	a,(dsectr)	;Sektornummer in 1..dpbspt ?
	dec	a		;ab 0 zaehlen
	jp	m,drwerr	;<0, Fehler
	cp	(ix+dpbspt)	;<dpbspt?
	jr	nc,drwerr	;nein, Fehler
 IF dbufsz gt 7
	ld	b,a		;retten dsectr-1
 ENDIF
	ld	a,(ix+dpbflg)
	and	dpbfsm		;Anzahl der abweich. 128er Spuren
	ld	e,a
	ld	d,0
	ld	hl,(dtrack)	;verlangte Spur
	or	a
	sbc	hl,de		;im abweichenden Spurformat?
	jp	c,drwsec	;ja, Sektorlaenge 128

 IF dbufsz gt 7	;gepufferte Disk E/A
 IF dbufsz lt 12 ;<2**12 =4K Puffer
	ld	a,(ix+dpbslc)	;phys. Sektorlaenge 128?
	or	a		;d.h. mit Sektorversatz?
	jp	z,drwsec	;ja, keine Pufferung sinnvoll
 ENDIF
	ld	a,b
	ld	d,(ix+dpbbfm)	;Puffermaske
	and	d		;rel. Sekt.nr. des BDOS-Blocks zum Puff.anf.
	push	af		;merken fuer move
	xor	b		;a ist Sektornr. des Puff.anf.
drwbnr:	srl	a		;ermitteln Puffernr in Spur
	rr	d		;noch Bits in Puffermaske?
	jr	nz,drwbnr	;ja
; Test, ob dieser Puffer da ist
	push	af		;merken Puffernummer
	ld	hl,dbnb
	cp	(hl)		;richtige Puffernummer?
	jr	nz,dbn		;nein
	ld	hl,(dtrack)	;geforderte Spur
	ld	de,(dbtrk)
	or	a
	sbc	hl,de		;richtige Spur?
	jr	nz,dbn
	ld	a,(dbdev)	;zum Puffer gehoeriges Geraet
	cp	c		;richtiges Geraet?
	jr	z,dbmat		;ja, Sektor steht im Puffer

dbn:	push	bc		;retten ddrive
	call	dbtrw		;veraenderten Puffer ausgeben
	pop	bc		;c:=ddrive
	ld	hl,dbdev
	ld	(hl),c
	ld	hl,(dtrack)
	ld	(dbtrk),hl
	call	dgetpb		;ix:=dpb(c)
	ld	b,(ix+dpbslc)
	ld	hl,dbslc
	ld	(hl),b
	ld	a,(ix+dpbbfm)	;Zahl der 128er Sektoren -1
	inc	a
	add	a,a		;CY:=0
	inc	b		;fuer djnz, falls dpbslc=0
dbsnbz:	rrca			;Zahl der phys. Sekt. im Puff.
	djnz	dbsnbz
	ld	d,a		;merken
	xor	a
	pop	bc		;b:=geforderte Puffernr.
	push	bc
	ld	hl,dbnb
	ld	(hl),b
	inc	b
	dec	b		;Puffernr. 0?
	jr	z,dbsec0	;ja
dbsecz:	add	a,d		;0. phys. Sekt. im Puffer
	djnz	dbsecz		;=dbsnb.*Puffernr.
dbsec0:	ld	e,a		;merken Pufferanf.-Sektor
	ld	b,(ix+dpbslc)
	ld	a,(ix+dpbspt)
	inc	b		;wegen djnz
	add	a,a
dbsecm:	srl	a		;phys. Sektoranzahl
	djnz	dbsecm
	sub	e		;Restsektorzahl auf Spur
	cp	d		;>= Zahl zu transferierender?
	jr	nc,dbseco	;ja
	ld	d,a		;sonst nur Restsektorzahl
dbseco:	inc	e		;Sektoren zaehlen ab 1
	ld	a,e
	ld	(dbsec),a	;Sektor
	ld	a,d
	ld	(dbsnb),a	;Sektorzahl
	ld	hl,dbflg
	res	dfbwr,(hl)
 if @write
	bit	dfbprr,(hl)	;muss neuer Puffer gel. werden?
	jr	nz,dbprr	;ja
; nur dann kein preread, wenn Rest BDOS-Block >= phys. Puff.
; und Rest BDOS-Block auf Pufferanfang beginnt
	ld	a,(unacnt)
	cp	(ix+dpbbfm)	;Restzahl-1 >= Puffergr.-1 ?
	jr	c,dbprr		;nein, preread
	ld	a,(dsectr)	;Sektornr.
	dec	a		;ab 0 zaehlen
	and	(ix+dpbbfm)	;rel. Sekt.nr. des
;				BDOS-Blocks zum Pufferanfang
	jr	nz,dbprr
	ld	(dberrf),a	;fehlerfrei gel. anzeigen
dbprr:	call	nz,dbtran	;Puffer lesen
 else
	call	dbtran
 endif
dbmat:	

; Sektor in/aus Puffer holen
;===========================
	pop	af		;Puffernr. in Spur wegschm.
	pop	af		;128-er Index im Puffer
	push	af
	rra			;Sektornb*128 berechnen
	ld	b,a
	ld	c,0
	rr	c
	ld	hl,dbuf
	add	hl,bc		;Adresse im Puffer
	ld	de,(ddma)	;Nutzer-DMA
	ld	a,(dflg)
	bit	dfwr,a		;Schreiben?
	jr	z,dsmove	;nein
	ld	a,(dbflg)
	set	dfbwr,a		;anzeigen Puffer beschrieben
	ld	(dbflg),a
	ex	de,hl
dsmove:	ld	bc,128
 IF dev eq cpd
	call	memldu		;ldir mit vorheriger Umschaltung auf RAM
 ELSE
	ldir
 ENDIF
	pop	af		;128-Index im Puffer
	cp	(ix+dpbbfm)	;letzter Sektor im Puffer
	jr	z,dmovew	;ja, Puffer ausgeben
	ld	a,(dwrtyp)
	cp	1		;write to directory?
dmovew:	call	z,dbtrw		;ja, veraend. Puffer ausgeben
	ld	a,(dberrf)	;Ergebnis letztes dbtran
	ret

; Schreiben Puffer, wenn notw.
;=============================
dbtrw:	ld	hl,dbflg
	bit	dfbwr,(hl)	;Puffer veraendert?
	ret	z		;nein, Schreiben unterdruecken
	ENDIF	;dbufsz gt 7

	IF	format or (dbufsz gt 7)
; gemeinsamer Zweig Lesen/Schreiben Puffer
;=========================================
dbtran:	
	ld	hl,dbcdb
	IF	dbufsz gt 7
	call	dsktra
	ld	(dberrf),a	;Fehlerflag stellen
	ld	hl,dbflg
	res	dfbwr,(hl)	;Puffer ist nicht beschrieben
	ret
	ELSE
	jr	dsktra
	ENDIF

	ENDIF

	IF	format
; Lesen beliebigen Sektor-Id.
;===========================
dsidtt:	ld	(dfrmtr),a	;Eingang fuer Spur in A
dsidtr:
	ld	hl,dfrcdb
 IF dsk8mf
	res	dioffm,(hl)	;nicht temporaer umschalten
	call	dsktra		;beliebigen Sektorid lesen
	ret	z		;ok
	ld	a,(ix+dpbtyp)
	and	(1 shl dpbt5z)+(1 shl dpbtdd)	;8"/5" und FM/MFM
	xor	1 shl dpbtdd	;8" MFM ?
	ret	nz		;nein, Fehler
	ld	hl,dfrcdb
	set	dioffm,(hl)	;temporaer auf FM umschalten
 ENDIF
	jr	dsktra		;belieb. SektId lesen
	ENDIF


; gemeinsamer Zweig Read/Write 128-Sektor einzeln
;================================================
drwsec:
	ld	hl,dcdb

; interner Aufruf phys. Diskettentransfer
;----------------------------------------
; i HL auf CDB
dsktra:
 IF dev eq cpd
	push	bc
	ld	de,diocdb	;CDB auf internen Hilfsspeicher
	ld	bc,diocdl	;da modifiziert
	push	de
	ldir
	jr	diskii
 ENDIF

;*********************************************************
; Umkleidung des physischer Disketten-Transfers
;*********************************************************

; Parameter: HL auf CDB mit folgender Struktur:
; +0: cdbfl	;Flags	(Struktur angepasst an ft.kom)
diof00	equ	0	;** frei fuer Anw. ** (frueher Verify nach Schreiben)
diofid	equ	1	;fest	;=1, wenn nur Sektid. zu lesen
diofwr	equ	2	;fest	;=1, wenn Schreiben
dioffm	equ	3	;fest	;=1, wenn temporaer FM-Format erzwungen
dioftr	equ	4		;=1, wenn keine Fehlermeldung (und -behandlg)
diofhd	equ	5		;=1, wenn Kopf hochnehmen ("headup")
diofps	equ	6		;=1, wenn trk,sid,sec schon physisch
diofs1	equ	7	;fest	;=1, wenn Rueckseite

; ab hier unwichtig bei "diofhd" in cdbfl =1 (headup)
; +1: cdbdev	;logisches Geraet 0 .. dphnb-1
; +2: cdbtrk	;log./phys. Spur
; +3: cdbsid	;bel./phys. Seite
; +4: cdbsec	;log./phys. Sektor
; +5: cdbslc	;Sektorlaengencode (0=128, 1=256, 2=512, 3=1024)
; +6: cdbsnb	;Anz. zu uebertr. ph. Sekt. (wenn =0, so nur position.)
; ab hier nur wichtig, wenn "diofid" in cdbfl =0:
; +7,8: cdbdma	;Transferadresse

; Return, falls nicht "diofhd" in cdbfl =1:
;	A=0 (ret z) bei fehlerfrei, sonst A=1 (ret nz) bei cdbfl, "dioftr" =0
;	oder Returncode phys. Transfer
;	E:=trk, D:=sid ,L:=sec, H:=len
;	BC,IX unveraendert

diskio:	;Aufruf ueber Sprungvektor von BIOS-Erweiterung
	push	bc
	ld	de,diocdb	;CDB des Nutzers auf internen Hilfsspeicher
	ld	bc,diocdl	;da modifiziert
 	push	de
 IF dev eq cpd
	call	memldu		;falls Original im ROM-Adressbereich
 ELSE
	ldir
 ENDIF
diskii:	pop	hl		;hl auf diocdb
	pop	bc

	bit	diofhd,(hl)	;Kopf hochnehmen?
 IF disknb ne 0
	jp	nz,headup	;ja, kein Transfer
 ELSE
	ret	nz		;ja, fertig
 ENDIF
	push	bc
	push	ix
	push	hl
 	inc	hl
	ld	c,(hl)		;logisches Laufwerk
	call	dgetpb		;IX auf DPB stellen
	pop	hl		;wiederherstellen hl
	ld	a,'D'		;falls LW nicht ex.
	jp	z,dioert	;LW ex. nicht

 IF hdsk
	bit	7,(ix+dpbdnr)	;harddisk?
	jr	nz,diophy	;ja, immer logisch=physisch
 ENDIF
	bit	diofps,(hl)	;trk,sid,sec schon physisch?
	jr	nz,diophy	;ja
 IF dsk8mf
	bit	dpbt52,(ix+dpbtyp)	;8" MFM?
	jr	z,drwnsp	;nein
	ld	a,(ix+dpbflg)
	and	dpbfsm		;Zahl der abweichenden 128er Sektoren
	ld	d,a
	ld	a,(dioctr)	;verlangte Spur
	cp	d		;im abweichenden Format?
	jr	nc,drwnsp	;nein
	set	dioffm,(hl)	;sonst temporaer FM erzwingen
drwnsp:
 ENDIF
; Track, Side und Sector entpsr. Diskettenformat setzen
	inc	hl
	inc	hl
	ld	d,(hl)		;Track
	ld	e,d		;merken
	inc	hl
	inc	hl
	ld	c,(hl)		;Sektornummer ab 1
	dec	c		;Sektornr. ab 0
	bit	dpbf86,(ix+dpbflg)	;Fortsetzung Dsk. auf Ruecks.?
	jr	nz,diots2	;ja
	bit	dpbfds,(ix+dpbflg)	;ungerade Spuren auf Rueckseite?
	jr	z,diotrs	;nein, einseitig
	srl	d		;Spur halbieren
	jr	nc,diotrs	;gerade Spur, Vorderseite
	jr	diots1		;auf Rueckseite
diots2:	ld	b,(ix+dpbtrk)	;log. Spurzahl
	srl	b		;Spuren auf Vorderseite
	ld	a,d
	sub	b		;Spur auf Vorderseite?
	jr	c,diotrs	;ja, Spur in d unveraendert lassen
				;40 ->  0; 41 ->  1; ...; 79 ->  39
				;77 ->  0; 78 ->  1; ...;153 ->  76
	bit	dpbfsv,(ix+dpbflg)	;Ruecks. von aussen nach innen?
	jr	nz,diots4	;ja
	cpl			;40 -> -1; 41 -> -2; ...; 79 -> -40
				;77 -> -1; 78 -> -2; ...;153 -> -77
	add	a,b		;40 -> 39; 41 -> 38; ...; 79 ->   0
				;77 -> 76; 78 -> 75; ...;153 ->   0
diots4:	ld	d,a
diots1:	ld	a,(diocfl)
	set	diofs1,a	;vermerken Rueckseite
	ld	(diocfl),a
	ld	a,(ix+dpbsn0)	;Versch. der Sektornr. auf Rueckseite
	add	a,c		;Sektornr. evtl. weiterzaehlen
;;;	cp	c		;Weiternummerierung auf Rueckseite?
	ld	c,a
;;;	jr	nz,diotrs	;ja, dann side:=0
	ld	a,1		;side:=1
	jr	diotss
diotrs:	xor	a		;side:=0
diotss:	ld	(diocsi),a	;phys. Seite setzen
	ld	a,d
	ld	(dioctr),a	;phys. Spur setzen

	ld	a,e		;log. Spurnr. zurueck nach A
	push	ix
	pop	hl
	ld	de,dpbstr	;d:=0
	add	hl,de
	cp	(ix+dpbofs)	;Systemspur?
	jr	c,diossp	;ja, Sektornummern nicht logisch
	ld	e,c
	add	hl,de		;HL entspr. Index in dpbstr
	ld	c,d		;c:=0
diossp:	ld	a,c		;phys. Sektornr. ab 0
	add	a,(hl)		;+echte Sektornr.
	ld	(diocse),a	;phys. Sektor setzen
diophy:

; i ret, BC, IX im Stack
; i cdb auf diocdb
; i IX auf DPB

diorty:	;interne Wiederholung diskio
	push	ix		;retten IX fuer evtl. Wiederholung
	ld	hl,diocdb
	push	hl
	ld	a,(hl)		;side 0/1, -/FM, read/write, -/sectid l.
 and (1 shl diofs1)+(1 shl dioffm)+(1 shl diofwr)+(1 shl diofid)
	ld	b,a
	lä	a,(ix+dpbtyp©	;5"/8"¬ FM/MFM¬ 40/80¬ Verifù nacè Schreiben
 and (1 shl dpbt80)+(1 shl dpbt5z)+(1 shl dpbtdd)+(1 shl dpbtwv) ;aus DPB
	xor	b
 IF dsk8mf
	bit	dpbffm,(ix+dpbflg)	;Diskette permanent FM?
	jr	z,dionfm	;nein
	res	dpbtdd,a		;erzwingen FM-Format
dionfm:
 ENDIF
	bit	dioftr,(hl)	;Fehlerbehandlung unterdruecken?
	jr	z,dionft	;nein
	inc	a
dionft:
	ld	(ft.kom),a	

	inc	hl
	ld	a,(ix+dpbdnr)	;physische LW-Nr.
	ld	(ft.lwn),a

	inc	hl
	ld	a,(hl)
	ld	(ft.trk),a
	inc	hl
	ld	a,(hl)
	ld	(ft.sid),a
	inc	hl
	ld	a,(hl)
	ld	(ft.sec),a
	inc	hl
	ld	a,(hl)
	ld	(ft.len),a
	inc	hl
	ld	a,(hl)
	ld	(ft.anz),a

	ld	a,(ix+dpbstp)	;Anzahl der Stepimpulse
	ld	(ft.stp),a

	ld	a,(ix+dpbsti)	;Schrittzeit
	ld	(ft.sti),a

	ld	hl,(diocad)
	ld	(ft.adr),hl

 IF stpvar or monitor
	call	delsps		;Sondertasten verbieten
 ENDIF
 IF hdsk
  IF disknb ne 0
	bit	7,(ix+dpbdnr)	;Harddisk?
	jr	z,callfl	;nein
  ENDIF
	call	hdisk
  IF disknb ne 0
	jr	callf1
callfl:	call	floppy
callf1:
  ENDIF
 ELSE
	call	floppy		;$$$ phys. Transfer $$$
 ENDIF
 IF stpvar or monitor
	call	delspr		;Sondertasten wieder erlauben
 ENDIF

	pop	hl		;HL wieder auf Paramfeld-Adresse
	pop	ix		;IX wieder auf DPB

dioert:
; Fehlerprotokoll
	bit	dioftr,(hl)	;Fehlerprotokoll und -behandlung  unterdr.?
	jr	nz,dtrok	;ja
	or	a		;Returncode
	jr	z,dtrok		; -> fehlerfrei
	cp	'R'		;not ready?
	jp	z,diorty	;ja, Wiederholung

 IF errvar
	ld	(derrcd),a	;Fehlercode
	bit	diofwr,(hl)	;war lesen?
	ld	a,'R'
	jr	z,derrr		;ja
	ld	a,'W'
derrr:	ld	(derrrw),a
  IF dev eq cpd
	ld	de,derrtr
	ld	a,(ft.trk)	;phys. Spur
	call	mrecoa
	ld	a,(ft.sid)	;Seite
	call	mrecoa
	ld	a,(ft.sec)	;Sektor
	call	mrecoa
  ELSE
	ld	hl,ft.trk	;phys. Spur
	ld	de,derrtr
	call	mbreco
	ld	hl,ft.sid	;Seite
	call	mbreco
	ld	hl,ft.sec	;Sektor
	call	mbreco
  ENDIF
	ld	hl,derrms
	call	biosms
 ENDIF
 	ld	a,1		;return mit Fehler

dtrok:	or	a		;stellen Z-Flag
	ld	de,(ft.trk)	;E:=trk, D:=sid
	ld	hl,(ft.sec)	;L:=sec, H:=len
	pop	ix
	pop	bc
	ret

 IF	format

; Stellen HL entsprechend Sektorlaengencode in (A)
;=================================================
; ret nz bei unzulaessigem
dtrsla:	or	a
	ld	hl,dtrsl0
	ret	z		;=0 (128)
	dec	a
	ld	hl,dtrsl1	;=1 (256)
	ret	z
	dec	a
	ld	hl,dtrsl2	;=2 (512)
	ret	z
	dec	a
	ld	hl,dtrsl3	;=3 (1024)
	ret

 ENDIF

;************************************************
;	Steuertabellen
;************************************************


 IF	format
; Modifizierungstabellen entspr. Sektorlaenge und LW-Typ
;-------------------------------------------------------

; Struktur:

dsltrk	equ	0		;benutzte Spuren
dslspt	equ	dsltrk+1	;Sektoren/Spur
dsldir	equ	dslspt+1	;Dir-Eintraege
dsloff	equ	dsldir+1	;2*offset
				;[+Flag fuer festes offset]
dslfo	equ	1		;festes offset
dslvo	equ	0		;offset =0, falls Directory mgl.
dslblk	equ	dsloff+1	;rel. Adr. Tab. BDOS-Blockgroesse
dsll	equ	5		;Laenge eines Eintrags

; Reihenfolge
; 5", 40 Tr, SS
; 5", 80 Tr, SS
; 5", 40 Tr, DS
; 5", 80 Tr, DS
 if	disk8
; 8", 77 Tr, SS, SD
  if dsk8mf
; 8", 77 Tr, SS, DD
  endif
 endif

; Zur automatischen Bestimmung des Spurformats wird dasjenige
; Format der Spur "dlgint" benutzt, alle folgenden Spuren
; muessen das gleiche Format haben!
dlgint	equ	3	;groesste Anzahl SS-Systemspuren

; 128
dtrsl0:	
	db	40,26,63,2*2+dslvo,dbl1k-$	;CP/M Standard
	db	80,26,127,2*2+dslvo,dbl2k-$
	db	80,26,127,2*0+dslfo,dbl2k-$
	db	160,26,127,2*0+dslfo,dbl2k0-$

	if	disk8
	db	77,26,63,2*2+dslvo,dbl1k-$	;CP/M Standard
	if	dsk8mf
	db	77,40,127,2*2+dslvo,dbl2k-$
	endif
	endif

; 256
dtrsl1:	
	db	40,32,63,2*3+dslfo,dbl2k-$	;SCP Hausformat A51xx
	db	80,32,63,2*3+dslfo,dbl2k-$	;SCP
	db	80,32,127,2*4+dslfo,dbl2k-$
	db	160,32,127,2*4+dslfo,dbl2k0-$	;SCP Hausformat PC1715

	if	disk8
	db	77,32,63,2*3+dslfo,dbl2k-$
	if	dsk8mf
	db	77,52,127,2*2,dslfo,dbl2k-$
	endif
	endif

; 512
dtrsl2:	
	db	40,36,0,2*0+dslfo,dbl1k-$
	db	80,36,0,2*0+dslfo,dbl2k-$
	db	80,36,0,2*0+dslfo,dbl2k-$
	db	160,36,0,2*0+dslfo,dbl2k0-$

	if	disk8
	db	77,36,127,2*2+dslvo,dbl2k-$	;Hausformat IH Mittweida
	if	dsk8mf
	db	77,64,127,2*2+dslvo,dbl2k0-$
	endif
	endif
	
; 1024
dtrsl3:	
	db	40,40,63,2*2+dslvo,dbl1k-$	;CP/A Standard A51xx
	db	80,40,127,2*2+dslvo,dbl2k-$	;CP/A
	db	80,40,127,2*0+dslvo,dbl2k-$	;CP/A
	db	160,40,191,2*4+dslvo,dbl2k0-$	;CP/A (und SCP)

	if	disk8
	db	77,32,63,2*3+dslvo,dbl2k-$	;CP/A und SCP
	if	dsk8mf
	db	77,64,127,2*2+dslvo,dbl2k0-$	;CP/A und SCP
	endif
	endif

; Modifizierungstabellen fuer BDOS-Blockgroesse
dbl1k:	db	3,7,0		;Bl. Shift, Bl. Mask, Ext. Mask
dbl2k:	db	4,0fh,1
dbl2k0:	db	4,0fh,0		;fuer Kapazitaet >255

; log. Sektortranslate-Tabelle fuer 26*128
xlt:	db	1,7,13,19,25,5,11,17,23,3,9,15,21
	db	2,8,14,20,26,6,12,18,24,4,10,16,22

 ENDIF	;format

