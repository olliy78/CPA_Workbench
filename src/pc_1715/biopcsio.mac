; SIO-Treiber, Version 28.09.87
; Aenderungen:
; - Statusabfrage jedesmal, auch wenn zuvor frei gemeldet
; - Pufferueberlauf bei UC1-Puffer kontrolliert
; - bei DC1/DC3 nach Initialisierung DC1/DC3 abgewartet (Fehler SD1157)
;   (max. 30 sec)
; - bei DTR nach Ausgabe jedes Zeichens 2 ms gewartet (sonst ab und
;   zu Zeichenverlust bei K6311, da Zusammenspiel mit CTS-Signal nicht
;   klappt!!)

cdsioi	equ	dumi		;keine Zeicheneingabe unterstuetzt

; Einzelzeichenausgabe Reg. A
cdsioo:	ld	c,(ix+ltpsd)	;Datenport
	out	(c),a
;;; Verzoegerung wegen CTS-Problemen beim K6311
	bit	7,(ix+ltpw5)	;Prozedur DTR?
	ret	z		;nein
	ld	c,2		;2ms Wait (damit Sende-/Empfangspuffer leer)
cdsod1:	ld	b,189		;(189*13)/(256*9699)=0.001
cdsod2:	djnz	cdsod2		;1ms warten
	dec	c		;fertig?
	jr	nz,cdsod1	;nein
;;;
	ret

;------------------------------------

; Statusabfrage
cdsios:	ld	a,(ix+ltpst)	;Status
	bit	1,a		;senderseitig blockiert?
	jr	nz,lstsr	;ja, frei rueckmelden
	or	a		;initialisiert?
	call	z,cdsin1	;nein
	bit	7,(ix+ltpw5)	;Prozedur DTR?
	JR	Z,lstsdc	;nein
	ld	c,(ix+ltpsc)	;SIO Kommando
	LD	d,00010000b	;Reset Ext/Status-Interrupt
	OUT	(C),d		;d.h. CTS in Reg. 0 abspeichern
	IN	a,(C)		;Leseregister 0
	BIT	5,a		;CTS?
	JR	Z,lstsr		;nein, besetzt
	BIT	2,a		;Sendepuffer leer? (nz bei ja)
; Ausgang Senderstatus
lstsr:
lstsr1:	ld	a,0ffh
	ret	nz		;senderseitig frei
	inc	a		;A=00, ret z
	RET			;senderseitig besetzt
;-----------------------
; DC1/DC3 und XON/XOFF
lstsdc:	LD	C,(ix+ltpsd)	;SIO Daten
	IN	A,(C)		;Status lesen (SIO speichert letzten Status)
	LD	(ix+ltpdc),A	;zuletzt empf. Zeichen merken
	and	7fh		;evtl. Paritaet ignorieren
	cp	11h		;DC1?
	jr	z,lstsd1	;ja
	xor	a		;A=00, ret z
	ret
lstsd1:	ld	c,(ix+ltpsc)	;SIO Kommando
	in	a,(c)
	bit	2,a		;Sendepuffer leer? (nz bei ja)
	jr	lstsr
;-----------------------

; (Re-)Initialisierung
; IX auf Steuertabelle
; ret: C zeigt auf Kommandoport
cdsin1:
cdsini:
	LD	(ix+ltpst),11h	;ist initial..; Status neu abfragen
	LD	(ix+ltpdc),13H	;DC3 nach Initialisierung simulieren
	push	ix
	pop	hl
	ld	bc,ltpini
	add	hl,bc
	call	portpr		;CTC, WR0, WR4, WR1, WR3
	call	ltpow5		;WR5
	bit	7,(ix+ltpw5)	;Prozedur DC1/DC3?
	ret	nz		;nein
	ld	b,c
	ld	c,(ix+ltpsd)	;Datenport
	ld	a,7fh		;Reset an Drucker
	out	(c),a
	ld	c,b
	ld	de,30*100	;max. Wartezeit ca. 30 sec (SD1157!)
cdsinw:	in	a,(c)
	bit	0,a		;Antwort da?
	ret	nz		;ja
	call	wait10		;10ms warten
	dec	de
	ld	a,d
	or	e		;max. Wartezeit abgelaufen?
	jr	nz,cdsinw	;nein
	ret			;sonst Drucker wohl nicht bereit

ltpow5:	LD	e,(ix+ltpw5)	;Prozedurtyp/Bitanzahl
; Stellen Schreibregister 5
; Reg. B,HL bleiben erhalten
ltpot5:	ld	a,5
	ld	c,(ix+ltpsc)
	OUT	(C),A
	OUT	(C),e
	RET

;-------------------------------------
 if iobuc1

; UC1-Routinen (ausser Senden)

; UC1: Empf.-Status
;==================
; o A=0, ret z	: kein Zeichen empfangen
; o A=ff,ret nz	: Zeichen da
uc1st:	ld	ix,lstuc1	;Stellen IX auf Steuertabelle
uc1si:	;interner Aufruf mit gestelltem IX
	bit	4,(ix+ltpst)	;initialisiert?
	jr	nz,uc1si1	;ja
	di
	xor	a
	ld	(uc1bfp),a	;Puffer leeren
	call	cdsini		;Initialisierung
	ld	hl,uc1i2	;WR1,WR2 programmieren
 	ld	b,4
	otir
	ei
uc1si1:	ld	a,(uc1bfp)	;Zeichen im Empfpuffer?
	or	a
	ret	z		;nein
	ld	a,0ffh
	ret

uc1i2:	db	1,00010100b	;Empfinterr. jedes Zeichen, Intv.mod.
	db	2,ivsio0	;Interruptvektor

; UC1: empf. Zeichen an Nutzer
;=============================
; o A:	aeltestes empf. Zeichen

uc1i:	ld	ix,lstuc1	;Stellen IX auf Steuertabelle

uc1ii:	;interner Aufruf mit gestelltem IX
	ei			;UC1:-Interrupt zulassen
uc1iw:	call	uc1si		;Zeichen da?
	jr	z,uc1iw		;nein ***keine Zeitueberwachung!***
	ld	hl,uc1bfp
	di
	ld	c,(hl)
	dec	(hl)		;Pufferlaenge -1
	ld	b,0
	inc	hl		;^(aeltestes Pufferzeichen)
	ld	a,(hl)		;Zeichen nach A
	ld	de,uc1buf+1
	ex	de,hl
	ldir			;Puffer aufschieben
	ei
	bit	7,(ix+ltpst)	;war Stopaufforderung?
	ret	z		;nein
	push	af		;retten Zeichen
	ld	a,(uc1bfp)	;Pufferbelegung
	cp	1*uc1bfl/3	;unter dem Limit?
	call	c,uc1ird	;ja, Senden wieder erlauben
	pop	af
	ret

uc1ird:	res	7,(ix+ltpst)
 if (iobuc1 mod 10)	;DTR
	jp	ltpow5		;DTR wieder setzen
 else		;DC1/DC3
	ld	a,11h		;DC1 (Senden wieder erlauben)
	LD	C,(ix+ltpsd)	;SIO Daten
	OUT	(C),A
	ret
 endif

; UC1: Empf.-Interrupt
;=====================
uc1rin:	ld	(intsp),sp
	ld	sp,intstk
	push	af
	push	hl
	push	de
	push	bc
	push	ix
	ld	hl,uc1rir
	push	hl
	ld	ix,lstuc1	;Stellen IX auf Steuertabelle
	ld	c,(ix+ltpsd)	;SIO Daten
	in	b,(c)		;Zeichen lesen
	ld	hl,uc1bfp	;Pufferzeiger zum zuletzt empf. Zeichen
	ld	a,(hl)
	cp	uc1bfl		;Puffer voll?
	ret	nc		;ja, Zeichen ignorieren
	cp	2*uc1bfl/3	;Puffer fast voll (SIO-Empf.puffer 3 Byte!)?
	call	nc,uc1ri1	;ja, DC3 senden bzw. DTR wegnehmen
	inc	(hl)		;+1
	ld	e,(hl)
	ld	d,0
	add	hl,de		;naechste freie Stelle
	ld	(hl),b		;Zeichen in Puffer
	ret
uc1rir:	pop	ix
	jp	intrbc		;fertig
; Stopaufforderung senden
; B,HL bleibt erhalten
uc1ri1:	set	7,(ix+ltpst)	;merken Stopaufforderung
 if (iobuc1 mod 10)	;DTR
	ld	e,(ix+ltpw5)
	res	7,e		;DTR loeschen
	jp	ltpot5
 else		;DC1/DC3
	ld	a,13h		;DC3 an Partner (Senden stopppen)
	LD	C,(ix+ltpsd)	;SIO Daten
	OUT	(C),A
	ret
 endif

; UC1: Interrupt Empf.-Fehler (Parit., Ueberlauf, Rahmenfehler)
;============================
uc1err:
	ld	(intsp),sp
	ld	sp,intstk
	push	af
	push	hl
	push	de
	push	bc
	push	ix
	ld	ix,lstuc1	;Stellen IX auf Steuertabelle
	ld	c,(ix+ltpsc)	;SIO Kommando
	ld	d,00110000b	;Reset Fehler-Interrupt
	out	(c),d
				;keine Fehlermeldung, da bei
				;Empf.ueberlauf alles noch
				;mehr verzoegert wird
	jr	uc1rir

; UC1: Empfangspuffer
;====================
uc1bfp:	db	0
uc1buf:	ds	uc1bfl,0 

 endif	;uc1


